<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta name="theme-color" content="#000000" />
    <title>LeetCode</title>
  </head>

  <body>
    <script>
      function log(...args) {
        console.log.apply(console, args);
      }

      // 基础算法之“字符串类”
      // 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
      /* var str = "Let's take LeetCode contest",
        newStr = "";
      var reverseWords = function (s) {
        // var arr = s.split(" ");
        // arr.forEach((word) => {
        //   word = word.split("").reverse().join("");
        //   newStr += ` ${word}`;
        // });
        // return newStr.trim();

        // let arr = s.split("").reverse().join("");
        // return arr.split(" ").reverse().join(" ");

        // log(s.split(/\s/g));  // ["Let's", "take", "LeetCode", "contest"]
        // log(s.match(/[\w']+/g)); // ["Let's", "take", "LeetCode", "contest"]
        // log(s.match(/[\S]+/g)); // ["Let's", "take", "LeetCode", "contest"]
        return str.length
          ? str
              .match(/[\S]+/g)
              .map((item) => {
                return item.split("").reverse().join("");
              })
              .join(" ")
          : "";
      };
      log(reverseWords(str)); */

      // 给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。重复出现的子串要计算它们出现的次数。
      var str = "1011001101101";
      var count = 0;
      var matchArr = str.match(/(1+|0+)/g);
      log(matchArr);
      for (var i = 0; i < matchArr.length - 1; i++) {
        count += Math.min(matchArr[i].length, matchArr[i + 1].length);
      }
      log(count);

      let arr = str.replace(/10/g, "1 0").replace(/01/g, "0 1").split(/\s/);
      log(arr);
      let n = 0;
      for (i = 0; i < arr.length - 1; i++) {
        n += Math.min(arr[i].length, arr[i + 1].length);
      }
      log(n);

      var countBinarySubstrings3 = function (s) {
        let r = [];

        let match = (str) => {
          let j = str.match(/^(0+|1+)/)[0];
          let o = (j[0] ^ 1).toString().repeat(j.length);
          let reg = new RegExp(`^(${j}${o})`);
          if (reg.test(str)) {
            return RegExp.$1;
          } else {
            return "";
          }
        };

        for (let i = 0; i < s.length - 1; i++) {
          let sub = match(s.slice(i));
          if (sub) {
            r.push(sub);
          }
        }
        return r.length;
      };
      log(countBinarySubstrings3(str));
      log("-----------------------------");

      let match = (str) => {  
        let j = str.match(/^(0+|1+)/)[0];
        let o = (j[0] ^ 1).toString().repeat(j.length);
        let reg = new RegExp(`^(${j}${o})`);
        if (reg.test(str)) {
          return RegExp.$1;
        } else {
          return "";
        }
      };
      log(match(str));

      // $1，$2表达的是小括号分组里面的内容：$1是第一个小括号里的内容，$2是第二个小括号里面的内容
      // log("20112233".replace(/^(\d{4})(\d{2})(\d{2})$/, "$1*$2-$3"));  // 2011*22-33
    </script>
  </body>
</html>
