[precommit 提交前格式化代码](https://prettier.io/docs/en/precommit.html)

[prettier 代码美化](https://prettier.io/docs/en/install.html)

> 数据结构是计算机存储、组织数据的方式，算法是系统描述解决问题的策略与指令(一系列解决问题的清晰指令)。<br />
> 程序 = 数据结构 + 算法。<br />
> 数据结构为算法提供服务，算法围绕数据结构操作。<br />
> 了解基本的数据结构和算法可以提高代码的性能和质量。<br />

> <font size=3 color=#666 face="黑体">示例</font>

### 2, 时间/空间复杂度计算

> 时间复杂度。1，一个函数，用大 O 表示，比如 O(1)、O(n)、O(logN)。2，定性描述该算法的运行时间<br />

```javascript
O(1);
let i = 0;
i+=1;

O(n);
for (let i = 0; i < n; i+=1>) {
  console.log(i)
}
// 前面两个相加，O(1)+O(n) = O(n)  // n足够大时，O(1)忽略不计了

O(n) * O(n) = O(n^2)
for (let i = 0; i < n; i+=1>) {
  for (let j = 0; j < n; j+=1>) {
    console.log(i, j)
  }
}

O(logN);就是以2为底数的logN
let i = 1;
while(i < n) {
  console.log(i);
  i *= 2;
}
// 复杂度的规则，2n，3n都是n，或者说只取复杂度最高的那个，2n是两个相同复杂度，所以最高的也是n
```

<p align="center"><img style="width: 600px;height: 352px;" src="https://github.com/AnDong4213/data_structure_and_algorithm/blob/main/images/imooc2/360%E6%88%AA%E5%9B%BE20210726202558786.jpg"></p>

> 空间复杂度。1，一个函数，用大 O 表示，比如 O(1)、O(n)、O(n^2)。2，算法在运行过程中临时占用存储空间大小的量度<br />

```javascript
O(1);
let i = 0;
i+=1;

O(n);
const list = [];
for (let i = 0; i < n; i+=1>) {
  list.push(i)
}

O(n^2);
const matrix = [];
for (let i = 0; i < n; i+=1>) {
  matrix.push([])
  for (let j = 0; j < n; j+=1>) {
    matrix[i].push(j)
  }
}
// 矩阵的本质就是一个二维数组，嵌套了两层数组，存储了n的2次方个变量，
```

### 3，数据结构之“栈”

> 栈是什么？ (蜂窝煤的顺序)<br />
> 栈是一个后进先出的数据结构。(放进去-push-入栈，拿出来-pop-出栈) <br />
> js 中没有栈，但可以用 Array 实现栈的所有功能 <br />
> 栈是一种遵循后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。<br />
> 在栈里，新元素都靠近栈顶，旧元素都接近栈底。<br />
> 栈也被用在编程语言的编译器和内存中保存变量、方法调用等。

`栈的使用场景`

> 需要后进先出的场景。(十进制转二进制，判断字符串的括号是否有效，函数调用堆栈)

### 4，数据结构之“队列”

> 队列和栈非常类似，但是使用了不同的规则。<br />
> 对列是遵循 FIFO(First In First Out，先进先出，也称为先来先服务)原则的有序集合。

### 5，数据结构之 “链表”

> 数组(或者也可以成为列表)是一种非常简单的存储数据序列的数据结构。链表是一种动态的数据结构。<br />
> 要存储多个元素，数组或(列表)可能是最常用的数据结构。有个缺点: (在大多数语言中)数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。<br />
> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。<br />
> 相对于传统数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素，然而链表需要使用指针。数组的另一个细节是可以直接访问任何位置的任何元素，而想要访问链表中间的一个元素，需要从起点(表头)开始迭代列表直到找到所需的元素。 `列表最后一个节点的下一个元素始终是 null`<br />

`双向链表`
`前端与链表: 使用链表指针获取 JSON 的节点值`

> 链表相比数组最重要的优点是，无需移动链表中的元素，就能轻松地添加和移除元素。当你需要添加和移除很多元素时，最好的选择就是链表，而非数组。<br />
> 数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由基于内存寻址的方式。 <br />
> 链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点。<br />

### 6，数据结构之 “集合”

> 集合是一种不允许值重复的顺序数据结构 。<br />
> 集合是由一组无序且唯一(即不能重复)的项组成的。

### 7，数据结构之 “字典和散列表”

> 学习使用字典和散列表来存储唯一值（不重复的值）的数据结构。介绍散列和字典这两种非顺序数据结构。<br />
> 集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。<br />
> 集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射<br />
> 字典也称作映射、符号表或关联数组。<br />

`创建字典，与Set类相似，ECMAScript 6 同样包含了一个Map类的实现，即我们所说的字典。`

#### “散列表---HashTable 类，也叫 HashMap 类，它是 Dictionary 类的一种散列表实现方式”

> 散列算法的作用是尽可能快地在数据结构中找到一个值。你已经知道如果要在数据结构中获得一个值（使用 get 方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。<br />

`散列表和散列集合，散列表和散列映射是一样的，在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、 移除或获取元素时，使用的是散列函数。来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。`

> 有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。<br />
> 使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接(它是解决冲突的最简单的方法，但是它在 HashTable 实例之外还需要额外的存储空间)、线性探查和双散列法。介绍前两种方法。<br />
