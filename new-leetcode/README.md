[precommit 提交前格式化代码](https://prettier.io/docs/en/precommit.html)

[prettier 代码美化](https://prettier.io/docs/en/install.html)

> 数据结构是计算机存储、组织数据的方式，算法是系统描述解决问题的策略与指令(一系列解决问题的清晰指令)。<br />
> 程序 = 数据结构 + 算法。<br />
> 数据结构为算法提供服务，算法围绕数据结构操作。<br />
> 了解基本的数据结构和算法可以提高代码的性能和质量。<br />

> <font size=3 color=#666 face="黑体">示例</font>

### 2, 时间/空间复杂度计算

> 时间复杂度。1，一个函数，用大 O 表示，比如 O(1)、O(n)、O(logN)。2，定性描述该算法的运行时间<br />

```javascript
O(1);
let i = 0;
i+=1;

O(n);
for (let i = 0; i < n; i+=1>) {
  console.log(i)
}
// 前面两个相加，O(1)+O(n) = O(n)  // n足够大时，O(1)忽略不计了

O(n) * O(n) = O(n^2)
for (let i = 0; i < n; i+=1>) {
  for (let j = 0; j < n; j+=1>) {
    console.log(i, j)
  }
}

O(logN);就是以2为底数的logN
let i = 1;
while(i < n) {
  console.log(i);
  i *= 2;
}
// 复杂度的规则，2n，3n都是n，或者说只取复杂度最高的那个，2n是两个相同复杂度，所以最高的也是n
```

<p align="center"><img style="width: 600px;height: 352px;" src="https://github.com/AnDong4213/data_structure_and_algorithm/blob/main/images/imooc2/360%E6%88%AA%E5%9B%BE20210726202558786.jpg"></p>

> 空间复杂度。1，一个函数，用大 O 表示，比如 O(1)、O(n)、O(n^2)。2，算法在运行过程中临时占用存储空间大小的量度<br />

```javascript
O(1);
let i = 0;
i+=1;

O(n);
const list = [];
for (let i = 0; i < n; i+=1>) {
  list.push(i)
}

O(n^2);
const matrix = [];
for (let i = 0; i < n; i+=1>) {
  matrix.push([])
  for (let j = 0; j < n; j+=1>) {
    matrix[i].push(j)
  }
}
// 矩阵的本质就是一个二维数组，嵌套了两层数组，存储了n的2次方个变量，
```

### 3，数据结构之“栈”

> 栈是什么？ (蜂窝煤的顺序)<br />
> 栈是一个后进先出的数据结构。(放进去-push-入栈，拿出来-pop-出栈) <br />
> js 中没有栈，但可以用 Array 实现栈的所有功能 <br />
> 栈是一种遵循后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。<br />
> 在栈里，新元素都靠近栈顶，旧元素都接近栈底。<br />
> 栈也被用在编程语言的编译器和内存中保存变量、方法调用等。

`栈的使用场景`

> 需要后进先出的场景。(十进制转二进制，判断字符串的括号是否有效，函数调用堆栈)

### 4，数据结构之“队列”

> 队列和栈非常类似，但是使用了不同的规则。<br />
> 对列是遵循 FIFO(First In First Out，先进先出，也称为先来先服务)原则的有序集合。

### 5，数据结构之 “链表”

> 数组(或者也可以成为列表)是一种非常简单的存储数据序列的数据结构。链表是一种动态的数据结构。<br />
> 要存储多个元素，数组或(列表)可能是最常用的数据结构。有个缺点: (在大多数语言中)数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。<br />
> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。<br />
> 相对于传统数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素，然而链表需要使用指针。数组的另一个细节是可以直接访问任何位置的任何元素，而想要访问链表中间的一个元素，需要从起点(表头)开始迭代列表直到找到所需的元素。 `列表最后一个节点的下一个元素始终是 null`<br />

`双向链表`
`前端与链表: 使用链表指针获取 JSON 的节点值`

> 链表相比数组最重要的优点是，无需移动链表中的元素，就能轻松地添加和移除元素。当你需要添加和移除很多元素时，最好的选择就是链表，而非数组。<br />
> 数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由基于内存寻址的方式。 <br />
> 链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点。<br />

### 6，数据结构之 “集合”

> 集合是一种不允许值重复的顺序数据结构 。<br />
> 集合是由一组无序且唯一(即不能重复)的项组成的。

### 7，数据结构之 “字典和散列表”

> 学习使用字典和散列表来存储唯一值（不重复的值）的数据结构。介绍散列和字典这两种非顺序数据结构。<br />
> 集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。<br />
> 集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射<br />
> 字典也称作映射、符号表或关联数组。<br />

`创建字典，与Set类相似，ECMAScript 6 同样包含了一个Map类的实现，即我们所说的字典。`

#### “散列表---HashTable 类，也叫 HashMap 类，它是 Dictionary 类的一种散列表实现方式”

> 散列算法的作用是尽可能快地在数据结构中找到一个值。你已经知道如果要在数据结构中获得一个值（使用 get 方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。<br />

`散列表和散列集合，散列表和散列映射是一样的，在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、 移除或获取元素时，使用的是散列函数。来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。`

> 有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。<br />
> 使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接(它是解决冲突的最简单的方法，但是它在 HashTable 实例之外还需要额外的存储空间)、线性探查和双散列法。介绍前两种方法。<br />

### 8，数据结构之 “树”

> 介绍的第一个非顺序数据结构是散列表，要学习另一种非顺序数据结构——树。<br />
> 树是一种分层数据的抽象模型。<br />
> 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点。节点分为内部节点和外部节点。有关树的另一个术语是子树。子树由节点和它的后代构成。节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。树的高度取决于所有节点深度的最大值。<br />

#### “二叉树和二叉搜索树”

> 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。<br />
> 二叉搜索树（BST）是二叉树的一种，但是它只允许你在 左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。<br />

`树的遍历`

> 广度优先遍历(队列)，广度有点遍历(BFS Breadth First Search) 就是一层一层输出 , 输出到最下层的叶子节点, 为空的时候结束<br />
> 深度优先遍历(使用递归)，深度优先遍历 (DFS Depth First Search) 就是一个节点不到头(叶子节点为空)不回头，就是我们所说的 先序遍历 中序遍历 后序遍历 , 先中后指的是根节点输出的时机<br />
> 递归的坏处就是 , 出入栈消耗大量的内存, 每一次方法的调用都会保存大量的变量, 多以对于遍历来说并不好 ,非递归遍历的实现 , 基于栈的实现, 对于遍历节点保存在栈中, 出入栈 , 主要利用栈的后进先出的特性 , 很好的保证了, 后进的优先遍历 .<br />

> 遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。访问树的所有节点有三种方式：中序、先序和后序。<br />
> 先序遍历。先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。<br />
> 中序遍历。中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。<br />
> 后序遍历。后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。。<br />

`搜索树中的值`

> 在树中，有三种经常执行的搜索类型：搜索最小值，搜索最大值，搜索特定的值 <br />

`自平衡树`

> BST 存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；<br />
> 这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作 Adelson-Velskii-Landi 树（AVL 树）。AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。<br />
> 在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）的差值，该值（hr－hl）应为 0、1 或 -1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念

`尽管AVL树是自平衡的，其插入或移除节点的性能并不总是最好的。更好的选择是红黑树。红黑树可以高效有序地遍历其节点。如果感兴趣的话，你还可以了解堆积树。`

### 8，数据结构之 “图”

> 图是一种非线性数据结构。图是网络结构的抽象模型。图是一组由边连接的节点（或顶点），任何二元关系都可以用图来表示。<br />
> 一个图 G = (V, E)由以下元素组成。<br />
> V：一组顶点，E：一组边，连接 V 中的顶点。<br />
> 由一条边连接在一起的顶点称为相邻顶点。一个顶点的度是其相邻顶点的数量。<br />
> 路径是顶点 v1, v2,…,vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。简单路径要求不包含重复的顶点。<br />
> 环也是一个简单路径。如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是 连通 的。<br />
> 图可以是无向的（边没有方向）或是有向的（有向图）。如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。图还可以是未加权的或是加权的。

> 图的表示：邻接矩阵，邻接表，关联矩阵。

> 拓扑排序——使用深度优先搜索。我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）。<br />
> 有向无环图（DAG）。拓扑排序只能应用于 DAG。使用深度优先搜索来实现拓扑排序。<br />

### 9，数据结构之 “堆”

> 树的高度和树节点的数量关系是 logK。<br />
> 堆是一种特殊的完全二叉树。 所有节点都大于等于（最大堆）或小于等于（最小堆）它的子节点。
